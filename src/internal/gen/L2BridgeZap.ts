/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface L2BridgeZapInterface extends utils.Interface {
  functions: {
    "WETH_ADDRESS()": FunctionFragment;
    "calculateSwap(address,uint8,uint8,uint256)": FunctionFragment;
    "deposit(address,uint256,address,uint256)": FunctionFragment;
    "depositETH(address,uint256,uint256)": FunctionFragment;
    "depositETHAndSwap(address,uint256,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "redeem(address,uint256,address,uint256)": FunctionFragment;
    "redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)": FunctionFragment;
    "redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "redeemv2(bytes32,uint256,address,uint256)": FunctionFragment;
    "swapAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)": FunctionFragment;
    "swapAndRedeemAndRemove(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint256,uint256)": FunctionFragment;
    "swapAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "swapETHAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)": FunctionFragment;
    "swapETHAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "swapMap(address)": FunctionFragment;
    "swapTokensMap(address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "WETH_ADDRESS"
      | "calculateSwap"
      | "deposit"
      | "depositETH"
      | "depositETHAndSwap"
      | "redeem"
      | "redeemAndRemove"
      | "redeemAndSwap"
      | "redeemv2"
      | "swapAndRedeem"
      | "swapAndRedeemAndRemove"
      | "swapAndRedeemAndSwap"
      | "swapETHAndRedeem"
      | "swapETHAndRedeemAndSwap"
      | "swapMap"
      | "swapTokensMap"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "WETH_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETH",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETHAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAndRemove",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemv2",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapAndRedeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapAndRedeemAndRemove",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapAndRedeemAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapETHAndRedeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapETHAndRedeemAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapMap",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokensMap",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "WETH_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositETHAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemAndRemove",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeemv2", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapAndRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapAndRedeemAndRemove",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapAndRedeemAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapETHAndRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapETHAndRedeemAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swapMap", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapTokensMap",
    data: BytesLike
  ): Result;

  events: {};
}

export interface L2BridgeZap extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L2BridgeZapInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Calculate amount of tokens you receive on swap
     * @param dx the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.
     * @param tokenIndexFrom the token the user wants to sell
     * @param tokenIndexTo the token the user wants to buy
     */
    calculateSwap(
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapAndRedeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapETHAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapETHAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    swapTokensMap(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;
  };

  WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

  /**
   * Calculate amount of tokens you receive on swap
   * @param dx the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.
   * @param tokenIndexFrom the token the user wants to sell
   * @param tokenIndexTo the token the user wants to buy
   */
  calculateSwap(
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * wraps SynapseBridge redeem()
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which underlying chain to bridge assets onto
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  deposit(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   */
  depositETH(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees
   * @param chainId which chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param to address on other chain to bridge assets to
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  depositETHAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * wraps SynapseBridge redeem()
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which underlying chain to bridge assets onto
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  redeem(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
   * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
   * @param chainId which underlying chain to bridge assets onto
   * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
   * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
   * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  redeemAndRemove(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    liqTokenIndex: PromiseOrValue<BigNumberish>,
    liqMinAmount: PromiseOrValue<BigNumberish>,
    liqDeadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees
   * @param chainId which underlying chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  redeemAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge redeemv2() function
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to redeem into the bridge
   */
  redeemv2(
    to: PromiseOrValue<BytesLike>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapAndRedeem(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapAndRedeemAndRemove(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    liqTokenIndex: PromiseOrValue<BigNumberish>,
    liqMinAmount: PromiseOrValue<BigNumberish>,
    liqDeadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapAndRedeemAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
    swapTokenIndexTo: PromiseOrValue<BigNumberish>,
    swapMinDy: PromiseOrValue<BigNumberish>,
    swapDeadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapETHAndRedeem(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapETHAndRedeemAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    dx: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
    swapTokenIndexTo: PromiseOrValue<BigNumberish>,
    swapMinDy: PromiseOrValue<BigNumberish>,
    swapDeadline: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapMap(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  swapTokensMap(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

    /**
     * Calculate amount of tokens you receive on swap
     * @param dx the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.
     * @param tokenIndexFrom the token the user wants to sell
     * @param tokenIndexTo the token the user wants to buy
     */
    calculateSwap(
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapAndRedeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapETHAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapETHAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    swapMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    swapTokensMap(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {};

  estimateGas: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Calculate amount of tokens you receive on swap
     * @param dx the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.
     * @param tokenIndexFrom the token the user wants to sell
     * @param tokenIndexTo the token the user wants to buy
     */
    calculateSwap(
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapAndRedeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapETHAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapETHAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapTokensMap(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Calculate amount of tokens you receive on swap
     * @param dx the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.
     * @param tokenIndexFrom the token the user wants to sell
     * @param tokenIndexTo the token the user wants to buy
     */
    calculateSwap(
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * wraps SynapseBridge redeem()
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which underlying chain to bridge assets onto
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapAndRedeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapETHAndRedeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapETHAndRedeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      dx: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      swapTokenIndexFrom: PromiseOrValue<BigNumberish>,
      swapTokenIndexTo: PromiseOrValue<BigNumberish>,
      swapMinDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    swapTokensMap(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
