/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface L1BridgeZapInterface extends utils.Interface {
  functions: {
    "WETH_ADDRESS()": FunctionFragment;
    "baseTokens(uint256)": FunctionFragment;
    "calculateRemoveLiquidityOneToken(uint256,uint8)": FunctionFragment;
    "calculateTokenAmount(uint256[],bool)": FunctionFragment;
    "deposit(address,uint256,address,uint256)": FunctionFragment;
    "depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "depositETH(address,uint256,uint256)": FunctionFragment;
    "depositETHAndSwap(address,uint256,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "redeem(address,uint256,address,uint256)": FunctionFragment;
    "redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)": FunctionFragment;
    "redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
    "redeemv2(bytes32,uint256,address,uint256)": FunctionFragment;
    "zapAndDeposit(address,uint256,address,uint256[],uint256,uint256)": FunctionFragment;
    "zapAndDepositAndSwap(address,uint256,address,uint256[],uint256,uint256,uint8,uint8,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "WETH_ADDRESS"
      | "baseTokens"
      | "calculateRemoveLiquidityOneToken"
      | "calculateTokenAmount"
      | "deposit"
      | "depositAndSwap"
      | "depositETH"
      | "depositETHAndSwap"
      | "redeem"
      | "redeemAndRemove"
      | "redeemAndSwap"
      | "redeemv2"
      | "zapAndDeposit"
      | "zapAndDepositAndSwap"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "WETH_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "baseTokens",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRemoveLiquidityOneToken",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateTokenAmount",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETH",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositETHAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAndRemove",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemv2",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapAndDeposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapAndDepositAndSwap",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "WETH_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "baseTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateRemoveLiquidityOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateTokenAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositETHAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemAndRemove",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemAndSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeemv2", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "zapAndDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zapAndDepositAndSwap",
    data: BytesLike
  ): Result;

  events: {};
}

export interface L1BridgeZap extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: L1BridgeZapInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    baseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Calculate the amount of underlying token available to withdraw when withdrawing via only single token
     * @param tokenAmount the amount of LP token to burn
     * @param tokenIndex index of which token will be withdrawn
     */
    calculateRemoveLiquidityOneToken(
      tokenAmount: PromiseOrValue<BigNumberish>,
      tokenIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { availableTokenAmount: BigNumber }>;

    /**
     * This shouldn't be used outside frontends for user estimates.
     * A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running
     * @param amounts an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.
     * @param deposit whether this is a deposit or a withdrawal
     */
    calculateTokenAmount(
      amounts: PromiseOrValue<BigNumberish>[],
      deposit: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Wraps SynapseBridge deposit() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge redeem() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    zapAndDeposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param liqDeadline latest timestamp to accept this transaction
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param swapDeadline latest timestamp to accept this transaction*
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    zapAndDepositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

  baseTokens(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Calculate the amount of underlying token available to withdraw when withdrawing via only single token
   * @param tokenAmount the amount of LP token to burn
   * @param tokenIndex index of which token will be withdrawn
   */
  calculateRemoveLiquidityOneToken(
    tokenAmount: PromiseOrValue<BigNumberish>,
    tokenIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * This shouldn't be used outside frontends for user estimates.
   * A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running
   * @param amounts an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.
   * @param deposit whether this is a deposit or a withdrawal
   */
  calculateTokenAmount(
    amounts: PromiseOrValue<BigNumberish>[],
    deposit: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Wraps SynapseBridge deposit() function
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  deposit(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge depositAndSwap() function
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees
   * @param chainId which chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to deposit into the bridge
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  depositAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   */
  depositETH(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees
   * @param chainId which chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param to address on other chain to bridge assets to
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  depositETHAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge redeem() function
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to redeem into the bridge
   */
  redeem(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
   * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
   * @param chainId which underlying chain to bridge assets onto
   * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
   * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
   * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  redeemAndRemove(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    liqTokenIndex: PromiseOrValue<BigNumberish>,
    liqMinAmount: PromiseOrValue<BigNumberish>,
    liqDeadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees
   * @param chainId which underlying chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param to address on other chain to redeem underlying assets to
   * @param token ERC20 compatible token to deposit into the bridge
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  redeemAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Wraps SynapseBridge redeemv2() function
   * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
   * @param chainId which chain to bridge assets onto
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to redeem into the bridge
   */
  redeemv2(
    to: PromiseOrValue<BytesLike>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token
   * @param chainId which chain to bridge assets onto
   * @param deadline latest timestamp to accept this transaction*
   * @param liquidityAmounts the amounts of each token to add, in their native precision
   * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to deposit into the bridge
   */
  zapAndDeposit(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    liquidityAmounts: PromiseOrValue<BigNumberish>[],
    minToMint: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token
   * @param chainId which chain to bridge assets onto
   * @param liqDeadline latest timestamp to accept this transaction
   * @param liquidityAmounts the amounts of each token to add, in their native precision
   * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
   * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
   * @param swapDeadline latest timestamp to accept this transaction*
   * @param to address on other chain to bridge assets to
   * @param token ERC20 compatible token to deposit into the bridge
   * @param tokenIndexFrom the token the user wants to swap from
   * @param tokenIndexTo the token the user wants to swap to
   */
  zapAndDepositAndSwap(
    to: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    liquidityAmounts: PromiseOrValue<BigNumberish>[],
    minToMint: PromiseOrValue<BigNumberish>,
    liqDeadline: PromiseOrValue<BigNumberish>,
    tokenIndexFrom: PromiseOrValue<BigNumberish>,
    tokenIndexTo: PromiseOrValue<BigNumberish>,
    minDy: PromiseOrValue<BigNumberish>,
    swapDeadline: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<string>;

    baseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Calculate the amount of underlying token available to withdraw when withdrawing via only single token
     * @param tokenAmount the amount of LP token to burn
     * @param tokenIndex index of which token will be withdrawn
     */
    calculateRemoveLiquidityOneToken(
      tokenAmount: PromiseOrValue<BigNumberish>,
      tokenIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This shouldn't be used outside frontends for user estimates.
     * A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running
     * @param amounts an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.
     * @param deposit whether this is a deposit or a withdrawal
     */
    calculateTokenAmount(
      amounts: PromiseOrValue<BigNumberish>[],
      deposit: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge deposit() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge depositAndSwap() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge redeem() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    zapAndDeposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param liqDeadline latest timestamp to accept this transaction
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param swapDeadline latest timestamp to accept this transaction*
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    zapAndDepositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {};

  estimateGas: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    baseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the amount of underlying token available to withdraw when withdrawing via only single token
     * @param tokenAmount the amount of LP token to burn
     * @param tokenIndex index of which token will be withdrawn
     */
    calculateRemoveLiquidityOneToken(
      tokenAmount: PromiseOrValue<BigNumberish>,
      tokenIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This shouldn't be used outside frontends for user estimates.
     * A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running
     * @param amounts an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.
     * @param deposit whether this is a deposit or a withdrawal
     */
    calculateTokenAmount(
      amounts: PromiseOrValue<BigNumberish>[],
      deposit: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge deposit() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge depositAndSwap() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge redeem() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    zapAndDeposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param liqDeadline latest timestamp to accept this transaction
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param swapDeadline latest timestamp to accept this transaction*
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    zapAndDepositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    WETH_ADDRESS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the amount of underlying token available to withdraw when withdrawing via only single token
     * @param tokenAmount the amount of LP token to burn
     * @param tokenIndex index of which token will be withdrawn
     */
    calculateRemoveLiquidityOneToken(
      tokenAmount: PromiseOrValue<BigNumberish>,
      tokenIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This shouldn't be used outside frontends for user estimates.
     * A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running
     * @param amounts an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.
     * @param deposit whether this is a deposit or a withdrawal
     */
    calculateTokenAmount(
      amounts: PromiseOrValue<BigNumberish>[],
      deposit: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge deposit() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    deposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     */
    depositETH(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to bridge assets to
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    depositETHAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge redeem() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeem(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param chainId which underlying chain to bridge assets onto
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    redeemAndRemove(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      liqTokenIndex: PromiseOrValue<BigNumberish>,
      liqMinAmount: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param chainId which underlying chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param to address on other chain to redeem underlying assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    redeemAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Wraps SynapseBridge redeemv2() function
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees*
     * @param chainId which chain to bridge assets onto
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to redeem into the bridge
     */
    redeemv2(
      to: PromiseOrValue<BytesLike>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param deadline latest timestamp to accept this transaction*
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     */
    zapAndDeposit(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token
     * @param chainId which chain to bridge assets onto
     * @param liqDeadline latest timestamp to accept this transaction
     * @param liquidityAmounts the amounts of each token to add, in their native precision
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param minToMint the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation
     * @param swapDeadline latest timestamp to accept this transaction*
     * @param to address on other chain to bridge assets to
     * @param token ERC20 compatible token to deposit into the bridge
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     */
    zapAndDepositAndSwap(
      to: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      liquidityAmounts: PromiseOrValue<BigNumberish>[],
      minToMint: PromiseOrValue<BigNumberish>,
      liqDeadline: PromiseOrValue<BigNumberish>,
      tokenIndexFrom: PromiseOrValue<BigNumberish>,
      tokenIndexTo: PromiseOrValue<BigNumberish>,
      minDy: PromiseOrValue<BigNumberish>,
      swapDeadline: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
